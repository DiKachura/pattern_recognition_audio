# -*- coding: utf-8 -*-
"""audio_classifier_gradio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QtDdSgqx6uO_Bz9PYTYCRbSCwBmHZTgV
"""

!pip install gradio

import gradio as gr
import librosa
import numpy as np
import pandas as pd
import scipy.stats
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from tensorflow.keras.models import model_from_json  # Импорт model_from_json
from tensorflow.keras.models import load_model
import pickle

# Загрузка архитектуры модели
json_file = open('/content/last_model_architecture_2 (1).json', 'r')
loaded_model_json = json_file.read()
json_file.close()
model = model_from_json(loaded_model_json)

# Загрузка весов модели
model.load_weights("/content/last_model_weights_2 (1).h5")

# Загружаем scaler и enc
with open('/content/scaler.pkl', 'rb') as file:
    scaler = pickle.load(file)
with open('/content/enc.pkl', 'rb') as file:
    enc = pickle.load(file)

from pydub import AudioSegment
import os

def process_audio(input_file):
    """Приводит файлы к формату mono,
    устанавливает частоту дискретизации 16000Гц,
    устанавливает размер выборки 16 бит,
    возвращает обработанный звук в виде объекта AudioSegment.

    Args:
        input_file: Путь к входному аудиофайлу.

    Returns:
        AudioSegment: Обработанный объект AudioSegment.
    """

    try:
        sound = AudioSegment.from_file(input_file)
        sound = sound.set_frame_rate(16000)
        sound = sound.set_sample_width(2)
        sound = sound.set_channels(1)
        return sound
    except Exception as e:
        print(f"Ошибка при обработке файла {input_file}: {e}")
        return None

def extract_features(sound):
    """Извлекает аудио-признаки из файла.

    Args:
        sound: Путь к аудиофайлу.

    Returns:
        pd.DataFrame: DataFrame с извлеченными признаками.
    """

    y, sr = librosa.load(sound)
    y_harmonic = librosa.effects.hpss(y)[0]
    mfccs = librosa.feature.mfcc(y=y_harmonic, sr=sr, n_mfcc=20)

    mfccs_mean = np.mean(mfccs, axis=1)
    mfccs_std = np.std(mfccs, axis=1)

    cent = librosa.feature.spectral_centroid(y=y, sr=sr)
    cent_mean = np.mean(cent)
    cent_std = np.std(cent)
    cent_skew = scipy.stats.skew(cent, axis=1)[0]

    rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr)
    rolloff_mean = np.mean(rolloff)
    rolloff_std = np.std(rolloff)
    rolloff_skew = scipy.stats.skew(rolloff, axis=1)[0]

    features = [
        cent_mean,
        cent_std,
        cent_skew,
        rolloff_mean,
        rolloff_std,
        rolloff_skew,
        *mfccs_mean,
        *mfccs_std
    ]

    return np.array(features).reshape(1, 46)

def predict_class(audio_file):
    """Предсказывает класс для загруженного аудиофайла."""

    audio = process_audio(audio_file)
    output_file = "processed_audio.wav"
    audio.export(output_file, format="wav")

    features = extract_features(output_file)
    features = scaler.transform(features)
    features = features.reshape(1, 46, 1)

    prediction = model.predict(features)
    predicted_class = np.argmax(prediction)
    class_name = enc.categories_[0][predicted_class]

    return class_name

# Интерфейс Gradio
iface = gr.Interface(
    fn=predict_class,
    inputs=gr.Audio(type="filepath"),
    outputs="text",
    title="Распознавание объектов по аудио сигналу",
    description="Загрузите аудиофайл и узнайте его класс"
)

iface.launch()

